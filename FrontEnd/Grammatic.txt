Tree          ::=   DefFunc '\0'
DefFunc       ::=   {Type Name '(' DefFuncArgs ')' '{' Condition }' } * | main
DefFuncArgs   ::=   Type Name {',' Type Nama } *

main          ::=   'start' Condition 'end'
Condition     ::=   { ConditionIf ConditionElif ConditionElse | Assign ';' | Cycle | CallFunc ';' }*
CallFunc      ::=   'call' Name '(' Args ')' | Return | BoolOperation 
Args          ::=   Name {',' Name} *
ConditionIf   ::=   'if' '(' CallFunc ')' '{' Condition '}'
ConditionElif ::=   { 'else if' '(' CallFunc ')' '{' Condition '}' }*
ConditionElse ::=   else '{' Condition '}'
Cycle         ::=   While | For
While         ::=   'while' '(' BoolOperation ')' '{' ConditionIf '}'
For           ::=   'for' '(' Assign ';' BoolOperation ';' Assign ')' '{' ConditionIf '}'
Assign        ::=   Type ? Name '=' CallFunc
BoolOperation ::=   AddSub { ['>' '>=' ... '==' '!=' '&&' '||'] AddSub } *
Return        ::=  'return' 'CallFunc'
AddSub        ::=   MulDiv { ['+' '-'] MulDiv } *
MulDiv        ::=   Pow { ['*' '/'] Pow } *
Pow           ::=   Not { '^' Not } *
Not           ::=   {'!' Minus}  | Minus
Minus         ::=   '-' MulDiv | Bracket
Bracket       ::=   '(' CallFunc ')' | Name | Number
Name          ::=   [letter] { [letter | number] } *
Number        ::=   ['0' - '9'] +
Type          ::=   {'int' 'double' 'char ' 'void'}
