Tree          ::=   DefFunc '\0'
DefFunc       ::=   {Type Name '(' DefFuncArgs ')' '{' Condition }' } *
DefFuncArgs   ::=   {Type Name} ? {',' Type Name } *

Condition     ::=   { If Elif Else | Cycle } *
If            ::=   {'if' '(' Assign ')' '{' Condition '}' } ?
Elif          ::=   { 'else if' '(' Assign ')' '{' Condition '}' } *
Else          ::=   { else '{' Condition '}' } ?

Cycle         ::=   While | For | Return ';'
While         ::=   'while' '(' Assign ')' '{' Condition '}'
For           ::=   'for' '(' DefVariable ';' Assign ';' Assign ')' '{' Condition '}'

Return        ::=   'return'  BoolOperation ';' | DefVariable

DefVariable   ::=   Type Name '=' BoolOperation | Assign

Assign        ::=   Name '=' BoolOperation | BoolOperation

BoolOperation ::=   AddSub { ['>' '>=' ... '==' '!=' '&&' '||'] AddSub } *
AddSub        ::=   MulDiv { ['+' '-'] MulDiv } *
MulDiv        ::=   Pow { ['*' '/'] Pow } *
Pow           ::=   CallFunc { '^' CallFunc } *

CallFunc      ::    Name '(' Args ')' | Minus
CallFuncArgs  ::=   {Assign} ? {',' Assign} *

Not           ::=   {'!' MulDiv} | Bracket
Minus         ::=   '-' MulDiv | Bracket

Bracket       ::=   '(' BoolOperation ')' | Number

Number        ::=   ['0' - '9'] + | Name
Name          ::=   [letter] { [letter | number] } *

Type          ::=   {'int' 'double' 'char' 'void'}


// справочник по обозначениям:
// * - повторять пока можно (>= 0 раз) (аналог while)
// + - повторить хотя бы раз и пока можно (>= 1 раз) (аналог do while)
// ? - сделать 1 раз если можно (аналог if)
