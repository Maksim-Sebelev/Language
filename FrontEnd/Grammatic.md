# Грамматика языка

```bash
Tree          ::=   DefFunc '\0'
DefFunc       ::=   {Type Name '(' DefFuncArgs ')' '{' Condition }' } *
DefFuncArgs   ::=   {Type Name} ? {',' Type Name } *

Condition     ::=   { If Elif Else | Cycle } *
If            ::=   {'if' '(' Assign ')' '{' Condition '}' } ?
Elif          ::=   { 'else if' '(' Assign ')' '{' Condition '}' } *
Else          ::=   { else '{' Condition '}' } ?

Cycle         ::=   While | For | Return ';'
While         ::=   'while' '(' Assign ')' '{' Condition '}'
For           ::=   'for' '(' DefVariable ';' Assign ';' Assign ')' '{' Condition '}'

Return        ::=   'return'  BoolOperation ';' | DefVariable

DefVariable   ::=   Type Name '=' BoolOperation | Assign
Assign        ::=   Name '=' BoolOperation | PpMM

PpMm          ::=   Name [ '++ '--' ] | PlusEqual
PlusEqual     ::=   Name ['+=' '-=' '*=' '/=' ] BoolOperation | BoolOperation

BoolOperation ::=   AddSub { ['>' '>=' ... '==' '!=' '&&' '||'] AddSub } *
AddSub        ::=   MulDiv { ['+' '-'] MulDiv } *
MulDiv        ::=   Pow { ['*' '/'] Pow } *
Pow           ::=   CallFunc { '^' CallFunc } *

CallFunc      ::    Name '(' Args ')' | Minus
CallFuncArgs  ::=   {Assign} ? { ',' Assign } *

Minus         ::=   '-' MulDiv | Not
Not           ::=   '!' MulDiv | Bracket

Bracket       ::=   '(' BoolOperation ')' | Number

Number        ::=   ['0' - '9'] + | Name
Name          ::=   [letter] { [letter | number] } *

Type          ::=   {'int' 'double' 'char' 'void'}
```

<br>
<br>
<br>

# Справочная информация по обозначениям

# Присваивание ::=

Присваивает правилу его лексическую интерпретацию.

# Операторы 
## \*
**Повторять пока можно (>= 0 раз) (аналог while).**

## \+
**Повторить хотя бы раз и пока можно (>= 1 раз) (аналог do while).**

## ?
**Сделать 1 раз если можно (аналог if).**

**Пример:**

```bash
['0' - '9'] +
[letter] *
Type ?
```
1. В первом случае лексический ализатор ожидает что в тексте программы встретится **хотя бы** цифра и после нее быть может (НЕ обязательно) еще несколько. Если цифр не было контретно это правило завершится синтаксической ошибкой.
2. Во втором случае лексический анализатор с_читает столько букв, сколько идет дальше в программе. Если букв нет совсем, то правило завершится корректно.
3. В третьем случае лексический анализатор попытаеся счиать тип, согласно правилу `Type`, а если не сможет правило все равно завершится корректно.

<br>

# Ковычки: ''
*Внутри ковычек ('') содержится текстовое представление элементов синтаксика языка.*

**Пример:**

```bash
'return' BoolOperation ';'
```
Здесь лексический анализатор ожидает в коде программе встретить слово `return`, после чего обработает правило `BoolOperation` и в конце будет ожидать ';.'

# Или: |

*Дает правилу альтернативу. Если текст программы не соотвествует правилу до `|`, то лексический анализатор попытается выполнить стоящее после `|`.*

**Пример:**

```bash
Number | Name
```
Здесь лексический анализатор попытается считать число из текста программы согласно правилу `Number`, а если не получится то попытается считать имя согласно правилу `Name`.

**Замечание:** К **любому** правилу никогда не относятся правила стоящие через 1 или несколько `|`.\
Например здесь
```bash
While | For | Return ';'
```
Правила `While` и `For` вовсе **не**обязаны заканчиваться точкой с запятой. Это относится **лишь** к правилу `Return`

<br>

# Скобки: [] {}

# {}
**Обьдинют правила. Нужны для использования вместе с операторами `\*`, `\+`, `?`.

**Пример:**

```bash
CallFunc { '^' CallFunc } *
```
Здесь лексический анализатор будет разберется с правилом `CallFunc`, после чего если встретит символ `^` будет разбирать программу согласно правилу `CallFunc`, и так пока будет встречать символ `^` после выхода из правила `CallFunc`.

<br>

# []
*Содержат множество возможных синтаскических конструкций. Те есть внутри них содержится перечень символов/слов которые разрешены в данном месте программы*.

**Пример:**
```bash
['0' - '9']
```

Здесь лексичексий анализатор попытается считать из программы цифру от 0 до 9.
